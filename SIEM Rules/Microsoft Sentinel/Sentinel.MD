# EntramoxReconciler – Microsoft Sentinel Detection Guide (KQL)

## Overview

This guide provides **generic Microsoft Sentinel detections (KQL)** to monitor identity lifecycle and privilege events generated by **entramoxreconciler** (Entra ID → Linux/Proxmox reconciliation).

Use these detections to create **Scheduled Analytics Rules** for:

* Local user creation / deletion
* Account lock / unlock
* Sudo granted / revoked (group + sudoers file)
* Users entering deletion grace period
* Proxmox (PVE) user enable / disable + metadata updates

---

## Data Sources Assumed

Your Linux host is forwarding logs into Microsoft Sentinel using one of:

* **Syslog** table (AMA Syslog)
* **CommonSecurityLog** table (CEF)
* **Custom Log table** (e.g. `Entramox_CL`)

Because environments differ, each detection is provided in a **generic template** form:

### Pick your base table

Replace `TABLE_HERE` and `MESSAGE_FIELD` with one of:

**Option A — Syslog**

* `TABLE_HERE = Syslog`
* `MESSAGE_FIELD = SyslogMessage`
* Host field often: `Computer` or `HostName`

**Option B — CommonSecurityLog**

* `TABLE_HERE = CommonSecurityLog`
* `MESSAGE_FIELD = Message`
* Host field often: `DeviceName`

**Option C — Custom table**

* `TABLE_HERE = Entramox_CL`
* `MESSAGE_FIELD = RawData` (or whatever your custom field is)

---

## Common Filter: “Only EntramoxReconciler Logs”

Use one (or both) depending on your ingestion:

```kql
| where MESSAGE_FIELD has "entramoxreconciler"
   or MESSAGE_FIELD has "/var/log/entramoxreconciler/thelog.log"
```

If you have a dedicated `Source` field, use that instead (stronger signal).

---

## 1) Local User Created (Authoritative)

Detect local user creation initiated by the reconciler.

```kql
TABLE_HERE
| where MESSAGE_FIELD has "Created local user:"
| extend User = extract(@"Created local user:\s+(\S+)", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, User, MESSAGE_FIELD
| summarize Count=count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Host, User
| extend AccountCustomEntity=User, HostCustomEntity=Host
```

**Recommended severity:** Medium
**Tactic:** Persistence (optional), Impact (optional)

---

## 2) Local User Deleted (Authoritative)

Detect local deletion via reconciler.

```kql
TABLE_HERE
| where MESSAGE_FIELD has "Deleted user (and home):"
| extend User = extract(@"Deleted user \(and home\):\s+(\S+)", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, User, MESSAGE_FIELD
| summarize Count=count(), DeletedAt=max(TimeGenerated) by Host, User
| extend AccountCustomEntity=User, HostCustomEntity=Host
```

**Recommended severity:** High
**Tactic:** Impact

---

## 3) User Locked / Unlocked (Authoritative)

Detect reconciler lock/unlock actions (preferred over raw auth noise).

```kql
TABLE_HERE
| where MESSAGE_FIELD has "Locked user:" or MESSAGE_FIELD has "Unlocked user:"
| extend Action = case(
    MESSAGE_FIELD has "Locked user:", "locked",
    MESSAGE_FIELD has "Unlocked user:", "unlocked",
    "unknown"
)
| extend User = extract(@":\s+(\S+)$", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, User, Action, MESSAGE_FIELD
| summarize Count=count(), LastSeen=max(TimeGenerated) by Host, User, Action
| extend AccountCustomEntity=User, HostCustomEntity=Host
```

**Recommended severity:**

* Lock = Medium
* Unlock = High
  **Tactic:** PrivilegeEscalation (unlock can be part of restoration), Persistence

---

## 4) User Marked for Deletion (Grace Period Started)

Detect the moment a user is removed from allow-groups and enters grace.

```kql
TABLE_HERE
| where MESSAGE_FIELD has "locked and marked for deletion"
| extend User = extract(@"User\s+(\S+)\s+not in Entra allow-groups", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, User, MESSAGE_FIELD
| summarize Count=count(), MarkedAt=max(TimeGenerated) by Host, User
| extend AccountCustomEntity=User, HostCustomEntity=Host
```

**Recommended severity:** Medium
**Tactic:** Impact

---

## 5) Sudo Granted / Revoked (Authoritative)

Detect reconciler-driven sudo lifecycle (sudoers file creation/removal).

```kql
TABLE_HERE
| where MESSAGE_FIELD has "Updated sudoers for" or MESSAGE_FIELD has "Removed sudoers file for"
| extend Action = case(
    MESSAGE_FIELD has "Updated sudoers for", "sudo_granted",
    MESSAGE_FIELD has "Removed sudoers file for", "sudo_revoked",
    "unknown"
)
| extend User = extract(@"for\s+([A-Za-z0-9._-]+)", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, User, Action, MESSAGE_FIELD
| summarize Count=count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Host, User, Action
| extend AccountCustomEntity=User, HostCustomEntity=Host
```

**Recommended severity:**

* Grant = High
* Revoke = Medium
  **Tactic:** PrivilegeEscalation

> Tip: If you want different severities, create **two rules** with the same query and add a `| where Action == "sudo_granted"` filter for the High one.

---

## 6) Proxmox (PVE) User Enabled / Disabled

Detect Proxmox account state changes driven by reconciler.

```kql
TABLE_HERE
| where MESSAGE_FIELD has "PVE user" and (MESSAGE_FIELD has "created" or MESSAGE_FIELD has "set enable=")
| extend UserId = extract(@"PVE user\s+(\S+)", 1, MESSAGE_FIELD)
| extend Enabled = extract(@"enable=(\d)", 1, MESSAGE_FIELD)
| extend State = case(Enabled == "1", "enabled", Enabled == "0", "disabled", "unknown")
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, UserId, State, MESSAGE_FIELD
| summarize Count=count(), LastSeen=max(TimeGenerated) by Host, UserId, State
| extend HostCustomEntity=Host
```

**Recommended severity:**

* Enabled = High
* Disabled = Medium
  **Tactic:** PrivilegeEscalation (enable), Impact (disable)

---

## 7) Proxmox (PVE) Metadata Updated (Firstname/Surname/Email/Comment)

This is useful if you log a line like:
`PVE user metadata updated: <upn> (email=True comment=True)`

```kql
TABLE_HERE
| where MESSAGE_FIELD has "PVE user metadata updated:"
| extend Upn = extract(@"PVE user metadata updated:\s+(\S+)", 1, MESSAGE_FIELD)
| extend Host = coalesce(tostring(Computer), tostring(HostName), tostring(DeviceName))
| project TimeGenerated, Host, Upn, MESSAGE_FIELD
| summarize Count=count(), LastSeen=max(TimeGenerated) by Host, Upn
| extend HostCustomEntity=Host
```

**Recommended severity:** Low / Informational
**Tactic:** None (Audit)

---

## Recommended Rule Configuration (Sentinel)

For most of these:

* **Run frequency:** 5 minutes
* **Lookup period:** 10 minutes
* **Suppression:** Optional 5–15 minutes for noisy environments
* **Incident grouping:** Group by `Host` + `User`/`Upn` where applicable
* **Entity mapping:**

  * Account → `AccountCustomEntity` (if present)
  * Host → `HostCustomEntity`

---

## Practical Notes

* Prefer **entramoxreconciler log-based detections** for high signal and low false positives.
* Use Linux auth/audit logs for **corroboration**, not as the primary alert.
* If you do not have consistent host fields, keep the `Host = coalesce(...)` pattern.

---

## Quick Start Checklist

1. Confirm where the reconciler logs land (`Syslog` vs custom table).
2. Replace:

   * `TABLE_HERE`
   * `MESSAGE_FIELD`
3. Create 5–7 Scheduled Analytics Rules from the queries above.
4. Split **sudo_granted** into its own rule (High severity).
5. Add a simple workbook/dashboard later (counts by Host, Users in grace period, etc.).
